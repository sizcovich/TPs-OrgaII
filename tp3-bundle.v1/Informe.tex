\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage[dvipsnames,usenames]{color}
\usepackage{float}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{graphicx}
\usepackage{subfloat}
\usepackage{framed}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref} \usepackage{calc}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{multicol}

\newcommand{\f}[1]{\text{#1}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\eme}{\mathcal{M}}
\newcommand{\emeh}{\widehat{\mathcal{M}}}
\newcommand{\ere}{\mathcal{R}}

\sloppy

\setlength{\voffset}{-0.5cm}
\setlength{\hoffset}{0.7cm}
\setlength{\headsep}{0pt}
\setlength{\headheight}{0pt}
\setlength{\oddsidemargin}{-0.7in}
\setlength{\marginparwidth}{-0.5cm}
\setlength{\textwidth}{18cm}
\setlength{\footskip}{2pt}
\setlength{\topmargin}{0in}
\setlength{\textheight}{25cm}
\setlength{\fboxrule}{3pt}

\begin{document}
\thispagestyle{empty}
\begin{center}

\Huge{ \bf{UNIVERSIDAD DE BUENOS AIRES}}
\\
\LARGE{\bf{Facultad de Ciencias Exactas y Naturales}}
\\
\textbf{Departamento de Computaci\'on}
\\
\textbf{Organizaci\'on del Computador}
\vspace{2.0\baselineskip}
\end{center}


\begin{figure}[h] %[h] Aqui [b] para button [t] para top
\begin{center}
\includegraphics[width=100pt]{./image.jpeg}
\end{center}
\end{figure}
\begin{center}
\vspace*{0.7cm}

\huge{\bf RECUPERATORIO AL TRABAJO PR\'ACTICO N\'UMERO 3}\\
\huge{Nombre de Grupo: Napolitana con Jam\'on y Morrones}
\vspace*{8cm}

\end{center}

\huge{\textbf{Alumnos:}}\\
\\
\vspace*{0.3cm}
\Large{\textsl{Izcovich, Sabrina} $|$ sizcovich@gmail.com $|$ LU 550/11}\\
\vspace*{0.3cm}
\Large{\textsl{L\'opez Veluscek, Matías} \hspace{0.1cm}$|$ milopezv@gmail.com $|$ 926/10}\\

 
\newpage
%Pagina de titulo e indice
\thispagestyle{empty}
%\large{
\tableofcontents
%}
\newpage
\section{Introducci\'on}
El siguiente trabajo práctico consiste en un conjunto de ejercicios en los que se aplican de forma gradual los conceptos de System Programming vistos a lo largo de la materia. El objetivo de éste consiste en construir un sistema capaz de correr el juego \textit{Infección}. Para la realización del mismo, debimos crear el soporte para que los jugadores (o sea las tareas) puedan ejecutar las reglas del juego. Dado que las tareas eran capaces de hacer cualquier cosa, debimos considerar que el sistema debía tener la capacidad de capturar cualquier problema y poder quitar a la tarea del juego.\newline
A lo largo del trabajo práctico, se utilizaron los mecanismos que posee el procesador para la programación desde el punto de vista del sistema operativo enfocados sobre el sistema de protección. En lo que sigue, se detallan explícitamente los pasos realizados para lograr el objetivo mencionado.

\section{Ejercicio 1}
En el primer ejercicio, nos limitamos a completar la GDT conformada por un arreglo de gdt\_entry tomando como ejemplo la entrada GDT\_NULL provista por la cátedra. Para ello, debimos definir tres segmentos de códigos y de datos, manteniendo el segmento NULL para el buen funcionamiento de la estructura. El primero de ellos (de nivel de privilegio 0) correspondiente al kernel, el segundo (de nivel 2) al árbitro y el tercero (de nivel 3) a los jugadores. Dado que la GDT tiene un formato de segmentacion flat, la base de cada segmento comienza en 0 y el límite consiste en el tamaño de la memoria que deseamos poder acceder. Cada segmento fue completado del siguiente modo:

\begin{table}[H]
\centering
    \begin{tabular}{|c|l|}
        \hline
        0xFFFF & limit[0:15] \\ 
        0x0000 & base[0:15] \\
        0x00 & base[23:16] \\ 
        0xX & type \\ 
        0x01 & s \\ 
        0xX & dpl \\ 
        0x01 & p \\ 
        0x07 & limit[16:19] \\ 
        0x00 & avl \\ 
        0x00 & l \\ 
        0x01 & db \\ 
        0x01 & g \\ 
        0x00 & base[31:24] \\ 
        \hline
    \end{tabular}
    \caption{GDT}
\end{table}

Dado que, como ya establecimos, se trata de una segmentaci\'on flat, las \'unicas diferencias entre los segmentos creados es el tipo y el DPL.\\
El DPL(Default Privilege Level) es el privilegio m\'inimo que necesita la tarea para acceder de cualquier forma a ese segmento, por lo tanto un proceso ejecut\'andose en el anillo de privilegio 3 no podr\'ia acceder a un segmento de privilegio 0, 1 o 2, pero cualquiera de estos otros privilegios si a uno de privilegio 3 ya que son m\'as privilegiados.\\
Por otro lado, el tipo del segmento es una combinaci\'on de 4 bits de los cuales el m\'as singificativo indica si se trata de un segmento de datos(0) o uno de c\'odigo(1); es importante la diferencia entre ambos porque no se puede ejecutar desde un segmento de datos así como no se puede escribir en un segmento de c\'odigo, por lo que es un nivel de protecci\'on extra contra acciones maliciosas. Por otro lado los siguientes 3 bits tienen funciones que dependen del tipo de segmento:

\begin{table}
	\centering
	\begin{tabular}{l | c | c | c |}
		& bit 10 & bit 9 & bit 8 \\ \hline
		Datos & Expand-Down & Write & Accessed \\ \hline
		C\'odigo & Conforming & Read & Accessed \\ \hline
	\end{tabular}
	\caption{Bits de tipo}
\end{table}

El bit 8 es el bit que indica si fue accedido o no el segmento, por defecto se configura en 0 porque al inicio del programa no puede haber sido accedido ning\'un segmento.\\
El bit 9 es el bit que indica, en caso de tratarse de un segmento de datos, si el segmento es de escritura o lectura/escritura o, en caso de tratarse de un segmento de c\'odigo, si es de ejecuci\'on o lectura. En caso de ser \'unicamente de ejecuci\'on, en caso de haber constantes en el c\'odigo estas no podr\'ian ser accedidas. Para que el kernel se ejecute correctamente pusimos este bit en 1 para que los segmentos de datos puedan ser escritos y los de c\'odigo le\'idos.\\
El bit 10 indica comportamientos un poco m\'as avanzados para los segmentos que no son usados en el TP y por lo tanto es configurado en 0. En el caso de ser un segmento de datos, este bit indica que el segmento ``crece hacia abajo'' como las pilas. En caso de ser un segmento de datos, este bit indica si se puede acceder al segmento desde un privilegio menor de manera directa o no.\newline

Finalmente se configuraron los selectores de segmento para que CS(Code) tenga el selector de segmento que corresponde al c\'odigo de nivel 0 y DS(Data), ES, FS, GS y SS(Stack) tengan el selector de segmento que corresponde al segmento de datos.

{\subsection{Pregunta 1:}} \textbf{¿Qué ocurre si se intenta escribir en la fila 26, columna 1 de la matriz de video, utilizando el segmento de la GDT que direcciona a la memoria de video? ¿Por qué?}\newline
\newline
\textit{La consecuencia de intentar escribir en la fila 26, columna 1 de la matriz de video accediendola desde el segmento declarado, es que se produce una interrupción 13(General Protection) porque se accede a memoria fuera del segmento.}\newline
\newline
{\subsection{Pregunta 2:}} \textbf{¿Qué ocurre si no se setean todos los registros de segmento al entrar en modo protegido? ¿Es necesario setearlos todos? ¿Por qué?}\newline
\newline
\textit{En el caso en el que los registros no se seteen se genera un General Protection; al menos se necesitan CS, DS y SS configurados correctamente para el funcionamiento en modo protegido, estos son el selector de c\'odigo, el selector de datos y el selector de stack respectivamente. Para respetar la convenci\'on C se deben inicializar tambi\'en los selectores de prop\'osito general, ES, FS y GS, al mismo valor que DS.}

\section{Ejercicio 2}
El ejercicio 2 nos plantea la creaci\'on de la Interrupt Descriptor Table(IDT) para responder ante las interrupciones de sistema(Interrupci\'on 0 a 19).\\
Las interrupciones se producen cuando se realiza alguna acción no permitida por el sistema y por lo tanto deben proveer una respuesta, ya sea desalojando a la tarea que cometi\'o el error o proveyendo del recurso necesario para que al retornar no se produzca el error. Puntualmente en esta instancia solo es necesario indicar de que interrupci\'on se trata, por lo que implementamos un macro gen\'erico que mostraba en pantalla el error y atrapaba la ejecuci\'on en un loop infinito.\newline

Para empezar creamos las entradas en la IDT, la cual se defini\'o en C como un arreglo de \verb+idt_entry+, un struct con la siguiente forma:
\begin{verbatim}
typedef struct str_idt_entry_fld {
	unsigned short offset_0_15;
	unsigned short segsel;
	unsigned short attr;
	unsigned short offset_16_31;
} __attribute__((__packed__, aligned (8))) idt_entry;
\end{verbatim}
Estas entradas estan compuestas por un selector de segmento(\verb+segsel+) que indica el segmento de la GDT donde se almacena el handler de la tarea, un offset(partido en los primeros y los \'ultimos 16 bits) que indica la posici\'on dentro del segmento y un campo \verb+attr+ que contiene los atributos de la entrada. Estos atributos indican de que tipo de interrupci\'on se trata, que permisos de usuario son necesarios para llamarla y si el segmento esta presente.\\
Para este kernel los atributos se configuraron para todas las entradas de interrupci\'on de sistema(0 a 19) el flag de segmento presente en 1(Presente), DPL 0 y tipo 1110(Interrupt Gate de 32 bits). El segmento es el de c\'odigo de nivel 0 y el offset es la direcci\'on f\'isica de la interrupci\'on ya que tenemos una segmentaci\'on flat.\newline

Para las rutinas de atenci\'on de las interrupciones se definieron los siguientes macros en assembly:

\begin{center}
		\begin{verbatim}
		%macro error 2
		error%1: db "Interrupcion ",%2
		error%1_len equ $ - error%1
		%endmacro

		%macro ISR 1
		global _isr%1

		_isr%1:
			mov eax, %1
			push ebx
			mov bx, es
			
			mov ecx, 4000
			mov ax, 0x38
			mov es, ax
			mov ax, 0x0F00
			.escribeTodo:
			mov [es:ecx], ax
			dec ecx
			loop .escribeTodo
			mov [es:ecx], ax
			mov es, bx
			pop ebx
			imprimir_texto_mp error%1, error%1_len, 0xF, 0, 0
			jmp $
		%endmacro

		%macro ISR_CODED 1
		global _isr%1

		_isr%1:
			add esp, 4
			mov eax, %1
			push ebx
			mov bx, es
			
			mov ecx, 4000
			mov ax, 0x38
			mov es, ax
			mov ax, 0x0F00
			.escribeTodo:
			mov [es:ecx], ax
			dec ecx
			loop .escribeTodo
			mov [es:ecx], ax
			mov es, bx
			pop ebx
			imprimir_texto_mp error%1, error%1_len, 0xF, 0, 0
			jmp $
		%endmacro
	\end{verbatim}
\end{center}

El macro \verb+error+ declara una etiqueta con una cadena de caracteres para imprimir en el mensaje de error, as\'i como una etiqueta con el largo de la cadena, estas etiquetas son luego utilizadas por los macros \verb+ISR+ e \verb+ISR_CODED+. Se tienen dos macros porque algunas interrupciones apilan tambi\'en un Error Code que a los efectos del TP es irrelevante, luego la \'unica diferencia entre ambos macros es que \verb+ISR_CODED+ descarta el Error Code de la tarea.\\
Ambos formatos de handler para las interrupciones borran la pantalla y luego imprimen el mensaje correspondiente.

{\textbf{Pregunta 3:}} ¿Cómo se puede hacer para generar una excepción sin utilizar la instrucción int? Mencionar al menos 3 formas posibles.\newline
\textit{
	Para generar una excepci\'on sin utilizar la instrucci\'on \texttt{int} se puede hacer uso de los siguientes m\'etodos:
	\begin{itemize}
		\item Dividiendo por 0.
		\item Escribiendo a un sector de memoria que no esta mapeado en la unidad de segmentaci\'on y/o paginaci\'on.
		\item Escribiendo a un sector de la memoria para el cual no se tiene suficiente nivel de permiso.
	\end{itemize}
}

{\subsection{Pregunta 4:}} \textbf{¿Cuáles son los valores del stack cuando se genera una interrupción? ¿Qué significan? (Indicar para el caso de operar en nivel 3 y nivel 0).}\newline
\newline
Cuando se genera una interrupción, se debe preservar el estado actual de los flags y todos los registros que son necesarios para retornar a la normal ejecución una vez resuelta la interrupción.
Cuando se produce la interrupción puede que sucedan 2 cosas, la interrupción tiene el mismo nivel de privilegio que el proceso en el que se generó o bien tiene un privilegio diferente. Exceptuando la tarea Idle que se ejecuta en nivel 0, todas las tareas, tanto \'arbitro como jugadores, se ejecutan en un nivel de privilegio menor que 0, por lo que siempre que suceda una interrupción de nivel 0 se producirá un cambio de privilegio con lo que el stack de la interrupción para una interrupción de nivel 0 es del formato de cambio de privilegio. Además, las interrupciones de servicio requieren un privilegio 2 o 3 para ser utilizadas, en cuyo caso las tareas no cambiarían de nivel al pedir llamar al servicio provisto para su nivel.

\begin{table}[h]
	\begin{minipage}{0.7\textwidth}
		\hspace*{0.3\textwidth}
		\begin{tabular}{|c|}
			\\ \hline
			Error Code \\ \hline
			EIP \\ \hline
			CS \\ \hline
			EFLAGS \\ \hline
			\\
		\end{tabular}
		\caption{Stack de interrupción sin cambio de privilegio}
	\end{minipage}
	~
	\begin{minipage}{0.7\textwidth}
		\hspace*{0.3\textwidth}
		\begin{tabular}{|c|}
			\\ \hline
			Error Code \\ \hline
			EIP \\ \hline
			CS \\ \hline
			EFLAGS \\ \hline
			ESP \\ \hline
			SS \\ \hline
			\\
		\end{tabular}
		\caption{Stack de interrupción con cambio de privilegio}
	\end{minipage}
\end{table}

Los datos que se almacenan por automático son entonces:
\begin{itemize}
	\item SS: El selector de segmento donde se encuentra el stack del nivel anterior, el cual se preserva por el cambio de stack al cambiar el privilegio.
	\item ESP: El puntero a la posición de memoria donde estaba el ESP antes del cambio de privilegio, el cual se preserva por el cambio de stack al cambiar el privilegio.
	\item EFLAGS: El registro que contiene el estado de los flags del sistema. Como muchas operaciones afectan el estado de este registro, se debe conservar para asegurarse de que el estado del proceso que se interrumpió sea el mismo que al salir de la interrupción.
	\item CS: El selector de segmento del proceso interrumpido.
	\item EIP: El puntero que indica que dirección se debe ejecutar al retornar de la interrupción.
	\item Error Code: El código de error, en caso de existir para la interrupci\'on, codifica información extra sobre el error para facilitar el diagn\'ostico del motivo de la interrupci\'on ya que pueden haber m\'ultiples causas.
\end{itemize}

El Error Code tiene 32 bits, de los cuales los bits 16 a 31 están reservados para mantener el stack alineado. El bit 0(EXT) indica si la interrupción es por un evento externo al procesador, el bit 1(IDT) indica si el índice, que va de los bits 3 a 15, hace referencia a un elemento de la IDT o a un descriptor en la GDT/LDT y el bit 2(TI) indica, solo en caso de que le bit 1 indique que se trata de un descriptor de GDT/LDT, en que tabla se encuentra el descriptor.\newline

\section{Ejercicio 3}
Para inicializar el Page Directory y el Page Table necesarios para que el kernel se siga ejecutando una vez activada la paginaci\'on, seg\'un la configuraci\'on que se usa en este trabajo práctico, es necesario reservar dos futuras p\'aginas de 4kb, una para el PD y otra para la PT.\\
Para empezar se analizaron las direcciones que se deseaban mapear como si mismas en la paginaci\'on. Estas direcciones lineales van desde la $0x00000000$ a la $0x00163FFF$, las cuales se interpretan de la siguiente forma: \newline
\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|}
		10 bits & 10 bits & \; \; 12 bits \; \; \\
		\hline
		PDIndex & PTIndex & Offset \\
		\hline
	\end{tabular}
	\caption{Interpretaci\'on de la direcci\'on lineal por la unidad de paginaci\'on}
\end{table}	\newline
Los 10 bits m\'as significativos cumplen el rol de \'indice del PD; en todas las direcciones estos bits son $0$, por lo que solo es necesario un PT. Entonces, en la p\'agina que empieza en $0x21000$ inicializamos la estructura del PD completamente vac\'ia y luego configuramos la primera entrada para que busque la PT en la p\'agina $0x22000$ como indica la consigna. Adem\'as configuramos la entrada para que la p\'agina no sea accesible por procesos de privilegio \textit{usuario}, sea de lectura y escritura y tambi\'en se indic\'o como presente en memoria. Un Page Directory Entry tiene la siguiente estructura:\newline
\begin{itemize}
	\item Los 20 bits m\'as significativos corresponden a los 20 bits m\'as significativos de la direcci\'on de la PT.
	\item Los siguientes 9 bits estan destinados a flags que no tienen relevancia para el TP.
	\item El bit 2 es el bit que indica el nivel de permiso, es decir, si la p\'agina mapeada requiere nivel de \textit{superusuario}($0$) o no($1$). En relaci\'on con la unidad de segmentaci\'on, se trata de \textit{superusuario} a los niveles 0, 1 y 2 y de \textit{usuario} al nivel 3.
	\item El bit 1 indica si la p\'agina es de solo lectura($0$) o si adem\'as puede ser modificada($1$).
	\item El bit 0 indica que la p\'agina se encuentra presente en memoria($1$) o no($0$).
\end{itemize}
Con el PD configurado correctamente continuamos con la configuraci\'on del PT. Los \'indices que se usan para esta van del $0$ al $355$, por lo que una vez inicializada la estructura vac\'ia, se configuraron las primeras $355$ entradas para que mapeen a la misma direcci\'on por la que se lleg\'o.\\
Un Page Table Entry tiene, a los efectos del trabajo pr\'actico, un formato id\'entico al del PDE exceptuando los primeros 20 bits que son los primeros 20 bits de la direcci\'on f\'isica que se desea mapear, siendo los 20 bits m\'as significativos los necesarios para encontrar el inicio de cada p\'agina de 4kb.\newline
Una vez inicializadas las entradas se activa la paginaci\'on con las siguientes lineas de c\'odigo assembly:
\begin{center}
	\begin{verbatim}
		mov eax, 0x00021000		;Cargo la direccion del directorio en cr3
		mov cr3, eax
		mov eax, cr0				
		or  eax, 0x80000000		;Activado el flag de paginacion
		mov cr0, eax
	\end{verbatim}
\end{center}
Como se indica en el c\'odigo, primero se carga en el registro CR3 la direcci\'on del PD y luego se activa el flag de paginaci\'on en CR0, de no ser así se producir\'ia un Page Fault al no poder encontrar el PD bien formado.

{\subsection{Pregunta 5:}} \textbf{¿Puede el directorio de páginas estar en cualquier posición arbitraria de memoria?}\newline
\newline
\textit{
	El directorio de p\'aginas debe estar en una p\'agina de 4kb ya que ocupa ese espacio en memoria; dicha p\'agina debe encontrarse en el espacio de memoria accesible antes de activar la paginaci\'on pues debe ser creada antes de activarla, de no tener un directiorio de p\'aginas al activar la paginaci\'on se produce un Page Fault ya que no tiene p\'aginas mapeadas ni un page directory en el que buscarlas.
}
{\subsection{Pregunta 6:}} \textbf{¿Es posible acceder a una página de nivel de kernel desde usuario?}\newline
\newline
\textit{
	Una p\'agina con privilegio de superusuario no puede ser accedida por un proceso con nivel de usuario, sin embargo un proceso con nivel de super usuario si puede acceder a una p\'agina con privilegio de usuario.
}

{\subsection{Pregunta 7:}} \textbf{¿Se puede mapear una página física desde dos direcciones virtuales
distintas, de manera tal que una esté mapeada con nivel de usuario y la otra a nivel de kernel? De ser posible, ¿Qué problemas puede traer?}\newline
\newline
\textit{
	Es posible, sin embargo el permitir el acceso a una misma p\'agina desde distintas direcciones virtuales con distinto privilegio podr\'ia permitir a un usuario modificar o acceder a datos que solo un superusuario deber\'ia poder acceder.
}

\section{Ejercicio 4}


{\subsection{Pregunta 8:}} \textbf{¿Qué permisos pueden tener las tablas y directorios de páginas? ¿Cuáles son los permisos efectivos de una dirección de memoria según los permisos del directorio y tabla de páginas?}\newline
\newline
\textit{Las tablas y directorios de páginas pueden tener permisos de usuario o supervisor, lectura o lectura/escritura. El permiso efectivo de una dirección de memoria es, principalmente, el permiso de la tabla de páginas. Esto se debe a que los permisos del page directory indican el permiso que se tiene sobre el page table mapeado en la pde con lo cual, si se tiene permiso de lectura, se aplican los permisos de la pte. En el caso en el que el page directory indicara que el page table tiene permiso de usuario entonces el usuario no tendría acceso a las páginas mapeadas en ese table.}

{\subsection{Pregunta 9:}} \textbf{¿Es posible desde dos directorios de página, referenciar a una misma tabla de páginas?}\newline
\newline
\textit{Es posible desde dos directorios de página referenciar a una misma tabla de páginas. Para que esto ocurra, debe escribirse la dirección de la tabla que se quiere referenciar en la entrada de cada directorio de tablas de páginas. Por ejemplo, esto puede ocurrir cuando dos tareas con directorios propios quieran referenciar las mismas páginas con distintos privilegios en las mismas direcciones físicas.}

{\subsection{Pregunta 10:}} \textbf{¿Qué es TLB (Translation Lookaside Buffer) y para qué sirve?}\newline
\newline
\textit{Consiste en una tabla en el proceso de memoria que contiene información sobre las páginas en memoria que el procesador accedió recientemente. La tabla hace remisión a direcciones virtuales del programa con las direcciones correspondientes en la memoria física que el programa usó más recientemente. El TLB permite mayor velocidad computacional debido a que facilita el proceso de direcciones que toman lugar independientemente del canal normal de traducción de direcciones.}

\section{Ejercicio 5}
{\subsection{Pregunta 11:}} \textbf{¿Qué pasa si en la interrupción de teclado no se lee la tecla presionada?}\newline
\newline
\textit{En el caso en el que la interrupción del teclado no lea la tecla presionada, dicha interrupción tendría un único comportamiento dado que no existe manera de saber qué tecla fue pulsada.}

{\subsection{Pregunta 12:}} \textbf{¿Qué pasa si no se resetea el PIC?}\newline
\newline
\textit{En el caso en el que el PIC no sea reseteado, más de una interrupción puede ser atendida por el mismo handler. Esto se debe a que el PIC se encuentra mapeado por defecto sobre interrupciones del sistema, por lo tanto, hay que configurarlo para que quede fuera del rango de las interrupciones de Intel.}

\section{Ejercicio 6}

{\subsection{Pregunta 13:}} \textbf{Colocando un breakpoint luego de cargar una tarea, ¿Cómo se puede verificar, utilizando el debugger de Bochs, que la tarea se cargó correctamente?
¿Cómo se llega a esta conclusión?}\newline
\newline
\textit{Para verificar que una tarea fue cargada correctamente, se puede pedir el $info\ tss$ en BOCHS y verificar que en el $TR$ se encuentra el selector de segmento que apunta al descriptor de tss de la tarea en la GDT. Por otro lado, el bit de Busy debe hallarse encendido.}

{\subsection{Pregunta 14:}} \textbf{¿Cómo se puede verificar que la conmutación de tarea fue exitosa?}\newline
\newline
\textit{Dicha verificación puede realizarse a partir de los registros TR y CR3. Si se deseara comprobar que la tarea desde la que se saltó guardó correctamente los valores en la tss, se debe volver a saltar a ella misma y comprobar que dichos valores sean los mismos.}


{\subsection{Pregunta 15:}} \textbf{Se sabe que las tareas llaman a la interrupción \texttt{0x80} y por \texttt{0x90}, ¿qué ocurre si esta no está implementada? ¿Por qué?}\newline
\newline
\textit{En el caso en el que se llame a la interrupción 0x80 y 0x90 y éstas no se encuentren definidas, se genera un General Protection.}

\section{Ejercicio 7}


\end{document}
