\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{a4wide}
\usepackage[dvipsnames,usenames]{color}
\usepackage{float}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

\newcommand{\f}[1]{\text{#1}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\eme}{\mathcal{M}}
\newcommand{\emeh}{\widehat{\mathcal{M}}}
\newcommand{\ere}{\mathcal{R}}

\sloppy

\setlength{\voffset}{-0.5cm}
\setlength{\hoffset}{0.7cm}
\setlength{\headsep}{0pt}
\setlength{\headheight}{0pt}
\setlength{\oddsidemargin}{-0.7in}
\setlength{\marginparwidth}{-0.5cm}
\setlength{\textwidth}{18cm}
\setlength{\footskip}{2pt}
\setlength{\topmargin}{0in}
\setlength{\textheight}{25cm}
\setlength{\fboxrule}{3pt}

\begin{document}
\thispagestyle{empty}
\begin{center}

\Huge{ \bf{UNIVERSIDAD DE BUENOS AIRES}}
\\
\LARGE{\bf{Facultad de Ciencias Exactas y Naturales}}
\\
\textbf{Departamento de Computaci\'on}
\\
\textbf{Organizaci\'on del Computador}
\vspace{2.0\baselineskip}
\end{center}


\begin{figure}[h] %[h] Aqui [b] para button [t] para top
\begin{center}
\includegraphics[width=100pt]{./image.jpeg}
\end{center}
\end{figure}
\begin{center}
\vspace*{0.7cm}

\huge{\bf TRABAJO PR\'ACTICO N\'UMERO 2}\\
\huge{Nombre de Grupo: Napolitana con Jam\'on y Morrones}
\vspace*{8cm}

\end{center}

\huge{\textbf{Alumnos:}}\\
\\
\vspace*{0.3cm}
\Large{\textsl{Izcovich, Sabrina} $|$ sizcovich@gmail.com $|$ LU 550/11}\\
\vspace*{0.3cm}
\Large{\textsl{L\'opez Veluscek, Matías} \hspace{0.1cm}$|$ milopezv@gmail.com $|$ 926/10}\\
\vspace*{0.3cm}
\vspace{0.5cm}
 
\newpage
%Pagina de titulo e indice
\thispagestyle{empty}
%\large{
\tableofcontents
%}
\newpage
\section{Introducci\'on}
El objetivo de este trabajo pr\'actico fue experimentar utilizando el modelo de programaci\'on SIMD. Para ello, fue requerido implementar seis filtros para procesamiento de im\'agenes (Recortar, Halftone, Umbralizar, Colorizar, Efecto Plasma y Rotar) tanto en $C$ como en $Assembler$.\newline
Por otro lado, debimos analizar la performance de un procesador al hacer uso de las operaciones SIMD. Para ello, realizamos comparaciones de velocidad entre los dos tipos de implementaciones realizados utilizando la herramienta Time Stamp Counter (TSC) del procesador.

\section{Desarrollo}
Nuestro trabajo consistió en implementar los filtros mencionados anteriormente. Para el desarrollo del mismo, diversas herramientas fueron necesarias. En esta sección, se explicita la utilización de las mismas aclarando en qué nos ayudaron a lograr una correcta ejecución de nuestra implementación.  
\subsection{Implementación en C}
En el caso de $C$, las implementaciones se realizaron siguiendo algoritmos sencillos. Para recorrer las matrices de píxeles utilizamos $for$ pues nos pareció lo más conveniente considerando que nuestros valores estaban pre-establecidos y que al colocar un for dentro de otro (uno para las filas y otro para las columnas) era más simple recorrer todas las posiciones de una matriz.\newline
Al probar iterar primero las columnas y luego las filas, rotar.c giraba la imagen hacia el otro lado; luego, nos decidimos por iterar primero las filas y luego las columnas.
\newline
Por otro lado utilizamos, como tipos de datos, enteros y doubles. Esto se debió a que era lo más conveniente para las operaciones que debía realizar nuestro programa ya que el nivel de precisón alcanzado era mayor y esa cualidad es muy importante para no perder información en cada píxel. Un incoveniente que tuvimos y que nos resultó llamativo fue al implementar rotar.c ya que al definir $\sqrt{2}/2$ como double la imagen obtenida presentaba diferencias con la imagen que debíamos encontrar. Para resolverlo, definimos $\sqrt{2}/2$ como float y dicho problema se solucionó.\newline
\newline
Luego, con el fin de disminuir el tiempo de ejecución de los $C$, comprimimos partes del código reduciendo, a su vez, la cantidad de líneas. También, alteramos pequeños detalles que sumados marcarían diferencia. Por ejemplo, cambiamos j++ por ++j.

\subsection{Implementación en Assembler}
En el caso de $Assembler$, utilizamos la extensión SSE para procesar varios bits a la vez. Esta herramienta nos permitió acelerar la ejecución de nuestro programa dado que en cada ciclo (en la mayoría de los casos) fueron tratados 16 bits a la vez.\newline
Nuestros filtros fueron realizados de la siguiente manera:
\begin{itemize}
\item {\textbf{Recortar:}}
En el caso del filtro recortar, procesamos los 4 cuadrantes de la imagen por separado para no confundir las posiciones de origen y destino de los píxeles por lo que la implementación de cada cuadrante resultó ser la misma a diferencia del offset de destino y origen.\newline
Dicha implementación consistió, a grandes rasgos, en levantar de a cada 16 bits desde la posición de origen y pegarlos en la posición de destino. Una vez alcanzado el valor de $tam$, la siguiente fila era procesada.	\newline
Para realizar dicha función no resultó necesario desempaquetar y empaquetar los píxeles pues no debían ser utilizados para realizar cuentas. Por lo tanto, a medida que se los levantaba, se los copiaba tal cual a la imagen destino.\newline
\newline
La función consistió en una seguidilla de los siguientes pasos:\newline
En primer lugar, se procesa el cuadrante B. Para ello, se le resta el $tam$ al ancho de la imagen para obtener el offset. Luego, se calcula el offset vertical de destino multiplicando el dst\_row\_size por tam.

\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones, el tiempo obtenido fue el siguiente:\newline

Implementación C\newline
----------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 857860615438390\newline
  Fin                               : 857860685974035\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 70535645\newline
  \# de ciclos insumidos por llamada : 705356.500\newline
\newline
Implementación ASM\newline
------------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 857860758957933\newline
  Fin                               : 857860759960311\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 1002378\newline
  \# de ciclos insumidos por llamada : 10023.780\newline
\newline
Resultados\newline
----------\newline

Ciclos C:                 705356.5\newline
Ciclos ASM:               10023.78\newline
Ciclos ASM respecto de C: 1.42109415593\% \newline
Tiempo C:                 70535645\newline
Tiempo ASM:               1002378\newline
Tiempo ASM respecto de C: 1.42109425667\% \newline


\item {\textbf{Halftone:}}

\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones, el tiempo obtenido fue el siguiente:\newline
\item {\textbf{Umbralizar:}}

\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones y 64 128 16 como parámetros, el tiempo obtenido fue el siguiente: \newline

Implementación C\newline
----------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 857572172822622\newline
  Fin                               : 857572676855448\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 504032826\newline
  \# de ciclos insumidos por llamada : 5040328.500\newline
\newline
Implementación ASM\newline
------------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 857572838473791\newline
  Fin                               : 857572938386751\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 99912960\newline
  \# de ciclos insumidos por llamada : 999129.625\newline
\newline
Resultados\newline
----------\newline

Ciclos C:                 5040328.5\newline
Ciclos ASM:               999129.625\newline
Ciclos ASM respecto de C: 19.8227084802\%\newline
Tiempo C:                 504032826\newline
Tiempo ASM:               99912960\newline
Tiempo ASM respecto de C: 19.8227089281\%\newline

\item {\textbf{Colorizar:}} 
\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones y 64 128 16 como parámetros, el tiempo obtenido fue el siguiente:\newline
\item {\textbf{Waves:}}

\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones y 2.0 4.0 16.0 como parámetros, el tiempo obtenido fue el siguiente:\newline

Implementación C\newline
----------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 858182624211702\newline
  Fin                               : 858224537429979\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 41913218277\newline
  \# de ciclos insumidos por llamada : 419132160.000\newline
\newline
Implementación ASM\newline
------------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 858224711685883\newline
  Fin                               : 858225286387416\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 574701533\newline
  \# de ciclos insumidos por llamada : 5747015.000\newline
\newline
Resultados\newline
----------\newline
Ciclos C:                 419132160.0\newline
Ciclos ASM:               5747015.0\newline
Ciclos ASM respecto de C: 1.37117013402\%\newline
Tiempo C:                 41913218277\newline
Tiempo ASM:               574701533\newline
Tiempo ASM respecto de C: 1.37117013826\%\newline

\item {\textbf{Rotar:}} 

\begin{itemize}
\item{Comparación de Tiempo}
\end{itemize}
Al probar lena.bmp de 512x512, con una cantidad de 100 iteraciones, el tiempo obtenido fue el siguiente:\newline
Implementación C\newline
----------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 858387565588994\newline
  Fin                               : 858388404276534\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 838687540\newline
  \# de ciclos insumidos por llamada : 8386875.500\newline
\newline
Implementación ASM\newline
------------------\newline

Tiempo de ejecución:\newline
  Comienzo                          : 858388558871397\newline
  Fin                               : 858388874991387\newline
  \# iteraciones                     : 100\newline
  \# de ciclos insumidos totales     : 316119990\newline
  \# de ciclos insumidos por llamada : 3161200.000\newline
\newline
Resultados\newline
----------\newline

Ciclos C:                 8386875.5\newline
Ciclos ASM:               3161200.0\newline
Ciclos ASM respecto de C: 37.6922251916\%\newline
Tiempo C:                 838687540\newline
Tiempo ASM:               316119990\newline
Tiempo ASM respecto de C: 37.6922244487\%\newline


\end{itemize}

hay que poner el pseudocodigo detallado que utilizamos explicando por que recorrimos de la manera que recorrimos la matriz y por que nos parecio lo mas efectivo y eficiente para programar, detallando para que sirve cada cosa. Tambien tenemos que decir que cosas hicimos para facilitar la implementacion en asm, o sea si lo hicimos pensando en como ibamos a resolverlo en asm o si directamente lo hicimos de una manera que fuera rapida. algo que se me ocurre es que preferimos, por ejemplo, usar muchas variables para definir pequeñas operaciones que usaba una sola ecuacion en vez de que fuera todo resuelto de una para poder darles tipos a esas operaciones y que el resultado fuera mas preciso y acertado a lo pedido.\newline

que transformaciones podriamos hacer para que sea mejor lo que hacemos, mejor tiempo, que fue lo que probamos, etc. Por ejemplo si paso de float a double. En umbralizar pasamos Q de float a double. Pusimos Q, max y min en double porque para hacer las cuentas con doubles era lo mas conveniente.
\newline
\section{Resultados}
Al observar el código generado por objdump para cada función en c, se pudo observar que su código assembler realizaba múltiples llamados a memoria. Ésto se debía a que todos los datos eran almacenados en la pila por lo que todo debía ser buscado allí, por ejemplo, [rbp-0x28].\newline
tenemos que ver el codigo en asm creado por el .c para decir por que nuestro asm funciona mas rapido que el generado por el .c, generalmente produce mas ciclos innecesarios o quizas contempla algun caso que no es importante (por ejemplo una altura o un ancho negativo). bueno obviamente hay que concluir que el .asm es mucho mas rapido que el .c.\newline
tenemos que hacer un grafico, creo que podriamos hacer uno que para cada funcion que hicimos ponga el tiempo que tardo en asm y en .c y que una por un lado todos los .c y por el otro todos los .asm cuestion de ver precisamente cual es la relacion entre la velocidad de un asm y de un .c. tambien tenemos que hacer uno que muestre graficamente el contenido de los xmm a medida que avanza la ejecucion del programa\newline
aca hay que poner tablas y graficos con los resultados. analizar y comparar las implementaciones. podriamos ejecutar el timing en distintas computadoras y ver que cambia respecto del procesador usado.
\section{Conclusi\'on}
C usa la FPU que es poco performante y lleva a un aumento del tiempo de ejecución.\newline
Reflexion final sobre alcance de la programacion vectorial a bajo nivel. 

\end{document}
